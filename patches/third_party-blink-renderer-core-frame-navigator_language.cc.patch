diff --git a/third_party/blink/renderer/core/frame/navigator_language.cc b/third_party/blink/renderer/core/frame/navigator_language.cc
index 174b1a2c0490c2fb8936f242c1048dfa04c02855..b7245ddbedf7a35e4f21c0720a3d0a0162f5dc0a 100644
--- a/third_party/blink/renderer/core/frame/navigator_language.cc
+++ b/third_party/blink/renderer/core/frame/navigator_language.cc
@@ -9,6 +9,13 @@
 #include "third_party/blink/renderer/platform/runtime_enabled_features.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_builder.h"
 
+#include "brave/third_party/blink/brave_page_graph/buildflags/buildflags.h"
+#if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+#include "brave/third_party/blink/brave_page_graph/page_graph.h"
+#include <sstream>
+#include <string>
+#endif
+
 namespace blink {
 
 Vector<String> ParseAndSanitize(const String& accept_languages) {
@@ -37,6 +44,27 @@ NavigatorLanguage::NavigatorLanguage(ExecutionContext* context)
 AtomicString NavigatorLanguage::language() {
   if (RuntimeEnabledFeatures::NavigatorLanguageInInsecureContextEnabled() ||
       context_->IsSecureContext()) {
+#if BUILDFLAG(BRAVE_PAGE_GRAPH_ENABLED)
+    {
+      // We need to make sure we don't call languages, since that would yield
+      // an incorrect graph in the end
+      EnsureUpdatedLanguage();
+      String result = languages_.front();
+
+      if (context_) {
+        brave_page_graph::PageGraph* page_graph =
+          brave_page_graph::PageGraph::GetFromIsolate(*context_->GetIsolate());
+        if (page_graph != nullptr) {
+          page_graph->RegisterWebAPICall("NavigatorLanguage.language",
+            std::vector<const String>());
+
+          page_graph->RegisterWebAPIResult("NavigatorLanguage.language", result);
+        }
+      }
+
+      return AtomicString(result);
+    }
+#endif
     return AtomicString(languages().front());
   }
   return AtomicString();
